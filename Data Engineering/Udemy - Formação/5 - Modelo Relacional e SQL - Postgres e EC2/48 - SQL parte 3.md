48. SQL Parte III
Nós vimos que uma característica dos bancos de dados relacionais e que isso traz como benefício a integridade e a redução da redundância dos dados e a divisão das entidades em tabelas fisicamente diferentes. E essa separação traz esses benefícios, mas também tem algumas desvantagens.
Então, por exemplo, se você quiser ter uma relação de vendas com o nome do vendedor, porque aqui, se você fizer um select em vendas, você não vai ter o nome do vendedor. Você vai ter apenas o ID do vendedor. O código dele e a chave estrangeira, que é a chave primária que veio de lá.
Então, a normalização tem esse lado negativo, ela traz a integridade, ela reduz a redundância mas você não tem as informações, além de códigos.
Para resolver isso, você precisa fazer join. Você precisa fazer consultas que juntem dados que você precisa de diferentes tabelas. Então, os joins eles podem ser feitos do lado esquerdo e do lado direito. Então, pode haver registros do lado esquerdo, que não tem referência ao lado direito e pode haver registro do lado direito, que não tem referência a lado esquerdo.
Vamos imaginar, eu posso ter um vendedor que não tem vendas? Posso. Então eu posso cadastrar o vendedor ainda. Ele ainda não tem vendas e eu posso ter uma venda que não tem nenhum vendedor bom.
Se a integridade do meu banco de dados permitir, posso ter uma venda sem vendedor que o cliente lá, por exemplo, pegou o produto no balcão e foi direto para o caixa certo.
O que acontece se eu fizer uma junção desses dados, eu posso fazer essa junção e, em alguns casos, eu posso ter vendas que não têm vendedor e eu posso ter vendedores que não estão em vendas, certo?
Então, qual é o problema disso? Imagine se você faz uma junção chave a chave. Por exemplo, se você quer ver vendas olhando e desde vendedor com id do vendedor para pegar nome,  bom o que acontece?
Nós vamos poder ter vendas que não têm ID do vendedor. Então, vamos supor que você tenha cinco vendas à venda número 1, 2, 3, 04 e 05.
Está vendo aqui?  Tem vendedor esta venda aqui tem vendedor, essa venda aqui tem vendedor, essa aqui tem esta, aqui não tem. Se eu fizer uma junção de vendas com vendedores, pegando apenas as vendas que tem vendedor, eu vou ter apenas esses quatro registros.
Se eu quiser que ela me traga as vendas, juntando com vendedores, mas também as vendas que não tem vendedor eu vou ter que fazer, ou um right join ou left join dependendo da onde eu coloquei a tabela na minha consulta.
Então é só pra você entender. Quando fizer o inner join, eu vou trazer o resultado da consulta que junte as duas tabelas onde exista sempre uma equivalência da chave. Se eu quiser trazer também registros que não tenham equivalência da chave do lado esquerdo eu uso um left join. Então aqui eu teria cinco registros com o left join. Ele me traria também os cinco registros e com o right join não teria o efeito contrário se eu usasse também as vendas.
Então os joins eles podem ser do tipo inner join. Ele só vai trazer os registros que houver equivalência da chave nas duas tabelas.
O Left Join. Ele vai trazer, mesmo que não tenha equivalência do lado esquerdo. 
E o right join ele vai trazer, mesmo que não tenha equivalência do lado direito.
Então aqui um exemplo aqui está usando o inner join. A gente tem 400 vendas, então nós no nosso banco de dados, todas as vendas têm um vendedor no banco de dados que nós vamos construir na aula prática.
Então, vejam aqui eu faço um select count um asterisco pra contar os registros. Do banco de dados relacional Vendas. As vendas aqui eu crio. Aliás, é aqui que está junção aqui que eu pego dados da outra tabela Inner join relacional ponto vendedores. As vendedores criam Alias, e aqui eu estou dizendo ele vai bater ou vai buscar a equivalência do ID do vendedor de vendas com o ID do vendedor de vendedores. Então ele vai me trazer apenas os registros que o vendedor.
Esteja nas vendas, o que acontece? Aí a gente vai ser um novo vendedor, esse vendedor. Ele não tem vendas ainda. Ele acabou de ser inserido e eu faço um write join,  esse write join em vez de me retornar 400 registros, ele me retorna 401. Porque? Porque eu tenho um vendedor que não tem venda. Então veja o resultado aqui. Eu faço right join em vez do left  join em vez de inner join que a gente tem ali em cima e vejam aqui o resultado. Ele me traz o registro de vendas, mas como não teve venda, ele me traz só o vendedor, ok? 
Então, essa é uma característica dos bancos de dados relacional.
Esse também é um dos problemas e uma das uma das questões que tornam os bancos de dados relacionais não muito propícios para questões analíticas. Como a gente já falou, eles são ótimos para operações, mas eles são mais complexos para questões analíticas. Por que? Porque se você quiser trazer dados consolidados, você vai ter que fazer junção entre muitas tabelas. Isso tem um custo computacional muito grande.
Você imagine milhões de registros com dezenas de tabelas que você vai ter lá, uma venda complexa ou uma transação complexa. Você tem que fazer junção com tudo isso.
O que acontece? Você vai ter que fazer junção dessas informações. Você vai ter que rodar essas consultas pesadas no sistema que está mantendo a empresa que está executando operações.
Eles estão vendendo, cadastrando produtos, despachando enfim, o sistema está operando. Você vai lá e roda uma consulta extremamente pesada. Você compromete a performance do sistema. Essa é uma das estresse e um dos problemas do banco de dados relacionais para questões analíticas.
Mas existem outras que são questões de não manter dados históricos, que são problemas que nós vamos estudar melhor nas sessões seguintes, ok.
Então, a gente vai ver também, na prática, o uso de joins nas questões, nas sessões práticas, no postgres.
